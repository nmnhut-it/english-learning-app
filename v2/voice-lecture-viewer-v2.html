<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Voice Lecture v2</title>
  <script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    :root{--primary:#0ea5e9;--primary-dark:#0284c7;--accent:#06b6d4;--success:#10b981;--warning:#f59e0b;--bg:#f0f9ff;--card:#fff;--text:#0f172a;--muted:#64748b;--border:#e0f2fe;--radius:12px;--safe-bottom:env(safe-area-inset-bottom,0)}
    body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:linear-gradient(180deg,#f0f9ff 0%,#e0f2fe 100%);color:var(--text);line-height:1.6;font-size:16px;min-height:100vh}

    /* Header */
    header{background:linear-gradient(135deg,#0284c7,#0ea5e9);color:#fff;padding:12px 16px;padding-top:calc(12px + env(safe-area-inset-top,0));position:fixed;top:0;left:0;right:0;z-index:100;display:flex;align-items:center;gap:12px;box-shadow:0 2px 12px rgba(14,165,233,.3)}
    header h1{font-size:.95rem;font-weight:600;flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    #progress{height:4px;background:rgba(255,255,255,.3);position:absolute;bottom:0;left:0;right:0;border-radius:2px}
    #progress-fill{height:100%;background:#fff;width:0%;transition:width .3s;border-radius:2px}

    /* Test Mode Banner */
    .test-banner{background:#fef3c7;color:#92400e;padding:8px 16px;text-align:center;font-size:12px;position:fixed;top:56px;left:0;right:0;z-index:99;border-bottom:1px solid #fcd34d}
    .test-banner.hidden{display:none}

    /* Content - Slide Container */
    #content{padding:68px 16px 140px;max-width:640px;margin:0 auto;min-height:100vh}
    .test-mode #content{padding-top:100px}

    /* Slide Counter in Header */
    .slide-counter{
      background:rgba(255,255,255,.2);
      padding:4px 12px;
      border-radius:20px;
      font-size:.8rem;
      font-weight:600;
      white-space:nowrap;
    }

    /* Chunks = Slides - Hidden by default, only active shows */
    .chunk{
      display:none;
      opacity:0;
      padding:16px 0;
      transition:opacity .4s ease;
    }
    .chunk[data-status="active"]{
      display:block;
      opacity:1;
      animation:slideIn .4s ease forwards;
    }
    .chunk[data-status="completed"]{display:none}
    .chunk[data-status="pending"]{display:none}

    @keyframes slideIn{
      from{opacity:0;transform:translateY(15px)}
      to{opacity:1;transform:translateY(0)}
    }

    .chunk-title{font-size:.75rem;color:#0369a1;text-transform:uppercase;letter-spacing:1px;margin-bottom:12px;font-weight:600;background:#e0f2fe;display:inline-block;padding:6px 14px;border-radius:20px}

    /* Fixed Bottom Navigation */
    #bottom-nav{
      position:fixed;
      bottom:0;
      left:0;right:0;
      background:linear-gradient(to top,#fff 80%,transparent);
      padding:20px 16px;
      padding-bottom:calc(20px + var(--safe-bottom));
      z-index:50;
    }
    #bottom-nav .nav-inner{
      max-width:640px;
      margin:0 auto;
    }
    #main-nav-btn{
      width:100%;
      padding:16px 24px;
      border-radius:50px;
      font-size:1.1rem;
      font-weight:600;
      border:none;
      cursor:pointer;
      transition:all .3s ease;
    }
    #main-nav-btn[data-ready="false"]{
      background:linear-gradient(135deg,#cbd5e1,#94a3b8);
      color:#fff;
      cursor:not-allowed;
      opacity:.6;
    }
    #main-nav-btn[data-ready="true"]{
      background:linear-gradient(135deg,#0ea5e9,#0284c7);
      color:#fff;
      box-shadow:0 4px 20px rgba(14,165,233,.4);
      animation:btnPulse 2s ease infinite;
    }
    @keyframes btnPulse{
      0%,100%{box-shadow:0 4px 20px rgba(14,165,233,.4)}
      50%{box-shadow:0 4px 30px rgba(14,165,233,.6)}
    }

    /* Typography */
    h1{font-size:1.25rem;margin:12px 0 8px;color:#0c4a6e}
    h2{font-size:1.1rem;margin:16px 0 8px;color:#0369a1;font-weight:700}
    h3{font-size:1rem;margin:12px 0 6px;font-weight:600;color:#075985}
    p{margin:6px 0}
    strong{color:#0284c7}
    em{color:var(--muted);font-style:normal}

    /* Teacher Script Container - Groups all scripts at chunk top */
    .ts-group{
      background:#f8fafc;
      border-radius:10px;
      padding:8px;
      margin-bottom:12px;
      border:1px solid #e2e8f0;
    }
    .ts-group-header{
      font-size:.65rem;
      color:#64748b;
      text-transform:uppercase;
      letter-spacing:.5px;
      margin-bottom:6px;
      padding-left:4px;
      display:flex;
      align-items:center;
      gap:4px;
    }
    .ts-group-header::before{content:'üë®‚Äçüè´'}

    /* Teacher Script - Compact single line style */
    .ts{
      background:linear-gradient(135deg,#f0f9ff,#e8f4fc);
      border-left:3px solid #0ea5e9;
      border-radius:0 6px 6px 0;
      padding:6px 10px;
      margin:4px 0;
      transition:all .2s ease;
      position:relative;
    }
    .ts-intro{display:none}
    .ts-content{
      color:#475569;
      font-size:.8rem;
      line-height:1.4;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    /* Expand on hover/focus */
    .ts:hover .ts-content,
    .ts:focus .ts-content,
    .ts[data-status="speaking"] .ts-content{
      white-space:normal;
      overflow:visible;
    }
    /* Active/Speaking state */
    .ts[data-status="speaking"]{
      background:linear-gradient(135deg,#dbeafe,#bfdbfe);
      border-left-color:#2563eb;
      box-shadow:0 2px 8px rgba(37,99,235,.15);
    }
    .ts[data-status="speaking"] .ts-content{color:#1e40af;font-weight:500}
    /* Completed/Played state */
    .ts[data-status="played"]{
      opacity:.4;
      background:#f8fafc;
      border-left-color:#cbd5e1;
    }
    .ts[data-status="played"] .ts-content{color:#94a3b8}

    /* Timer - Compact floating version */
    .timer{position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:linear-gradient(135deg,#0c4a6e,#075985);color:#fff;padding:8px 16px;border-radius:50px;display:none;box-shadow:0 4px 16px rgba(12,74,110,.4);z-index:100;align-items:center;gap:12px}
    .timer[data-active="true"]{display:flex}
    .timer-label{font-size:.75rem;opacity:.8;white-space:nowrap}
    .timer-time{font-size:1.25rem;font-weight:700;min-width:48px;text-align:center}
    .timer-time[data-warning="true"]{color:#fcd34d}
    .timer-time[data-danger="true"]{color:#fca5a5;animation:pulse 1s infinite}
    @keyframes pulse{50%{opacity:.6}}
    .timer-skip{background:rgba(255,255,255,.2);border:none;color:#fff;padding:6px 14px;border-radius:20px;cursor:pointer;font-weight:500;font-size:.85rem;white-space:nowrap}

    /* Cards */
    .card{background:var(--card);border-radius:var(--radius);padding:14px;margin:12px 0;box-shadow:0 2px 8px rgba(0,0,0,.06);border:1px solid var(--border)}
    .task-box{background:linear-gradient(135deg,#f0f9ff,#e0f2fe);border-left:4px solid var(--primary);border:none}
    .answer-box{background:linear-gradient(135deg,#ecfdf5,#d1fae5);border-left:4px solid var(--success);border:none}
    .grammar-box{background:linear-gradient(135deg,#f5f3ff,#ede9fe);border-left:4px solid #8b5cf6;border:none}
    .dialogue-box{background:linear-gradient(135deg,#f0fdf4,#dcfce7);border-left:4px solid var(--success);border:none}

    /* Vocabulary Interactive */
    .vocab-interactive{background:linear-gradient(135deg,#f0f9ff,#e0f2fe);border-radius:16px;padding:16px;margin:12px 0;border:2px solid #bae6fd}
    .vocab-interactive[data-status="complete"]{border-color:var(--success)}
    .vocab-phase{display:none}
    .vocab-phase[data-active="true"]{display:block}

    /* Vocab Progress Dots */
    .vocab-progress{display:flex;gap:6px;margin-bottom:16px;flex-wrap:wrap}
    .vocab-progress-dot{width:10px;height:10px;border-radius:50%;background:#cbd5e1;transition:all .3s}
    .vocab-progress-dot[data-status="done"]{background:#10b981}
    .vocab-progress-dot[data-status="current"]{background:#0ea5e9;transform:scale(1.3);box-shadow:0 0 8px rgba(14,165,233,.5)}

    /* Flashcard Start State - Compact */
    .vocab-start-state{background:#fff;border-radius:16px;padding:24px;text-align:center;box-shadow:0 4px 16px rgba(0,0,0,.08);border:2px dashed #7dd3fc}
    .vocab-start-icon{font-size:3rem;margin-bottom:12px}
    .vocab-start-title{font-size:1.1rem;font-weight:600;color:#0369a1;margin-bottom:8px}
    .vocab-start-count{font-size:.9rem;color:#64748b;margin-bottom:16px}
    .vocab-start-btn{background:linear-gradient(135deg,#0ea5e9,#0284c7);color:#fff;border:none;padding:16px 32px;border-radius:50px;font-size:1.1rem;font-weight:600;cursor:pointer;transition:all .2s;box-shadow:0 4px 16px rgba(14,165,233,.4);animation:startPulse 2s ease infinite}
    .vocab-start-btn:hover{transform:scale(1.05);box-shadow:0 6px 20px rgba(14,165,233,.5)}
    @keyframes startPulse{0%,100%{box-shadow:0 4px 16px rgba(14,165,233,.4)}50%{box-shadow:0 4px 24px rgba(14,165,233,.6)}}
    .vocab-learning-state{display:none}
    .vocab-phase[data-learning="true"] .vocab-start-state{display:none}
    .vocab-phase[data-learning="true"] .vocab-learning-state{display:block}

    /* Flashcard */
    .flashcard{background:#fff;border-radius:16px;padding:20px 16px;text-align:center;box-shadow:0 4px 16px rgba(0,0,0,.08);min-height:160px;display:flex;flex-direction:column;justify-content:center;position:relative}
    .flashcard[data-flipped="true"] .flashcard-front{opacity:0}
    .flashcard[data-flipped="true"] .flashcard-back{opacity:1}
    .flashcard-front,.flashcard-back{transition:all .4s}
    .flashcard-back{position:absolute;inset:0;display:flex;flex-direction:column;justify-content:center;padding:20px 16px;opacity:0}
    .flashcard-word{font-size:1.5rem;font-weight:700;color:#0284c7;margin-bottom:4px}
    .flashcard-pron{font-size:1rem;color:#64748b;font-family:monospace;margin-bottom:8px}
    .flashcard-meaning{font-size:1.2rem;color:#0f172a;margin-top:8px}

    /* Quiz */
    .quiz-question{background:#fff;border-radius:16px;padding:20px;margin-bottom:16px;text-align:center}
    .quiz-word{font-size:1.8rem;font-weight:700;color:#0284c7}
    .quiz-options{display:flex;flex-direction:column;gap:10px}
    .quiz-option{background:#fff;border:2px solid #e2e8f0;border-radius:12px;padding:14px 16px;cursor:pointer;transition:all .2s}
    .quiz-option:hover{border-color:#0ea5e9;background:#f0f9ff}
    .quiz-option[data-selected="true"]{border-color:#0ea5e9;background:#e0f2fe}
    .quiz-option[data-result="correct"]{border-color:#10b981;background:#d1fae5}
    .quiz-option[data-result="wrong"]{border-color:#ef4444;background:#fee2e2}

    /* Game */
    .game-container{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .game-item{background:#fff;border:2px solid #e2e8f0;border-radius:10px;padding:12px;cursor:pointer;min-height:48px;display:flex;align-items:center;justify-content:center;text-align:center}
    .game-item[data-selected="true"]{border-color:#0ea5e9;background:#e0f2fe}
    .game-item[data-matched="true"]{border-color:#10b981;background:#d1fae5;opacity:.6;pointer-events:none}

    /* Old chunk-nav - kept for compatibility but hidden */
    .chunk-nav{display:none}

    /* NPC System */
    #npc-overlay{position:fixed;inset:0;background:rgba(0,0,0,0);pointer-events:none;z-index:200;transition:background .4s}
    #npc-overlay[data-active="true"]{background:rgba(0,0,0,.7);pointer-events:auto}
    #npc-container{position:fixed;bottom:20px;left:20px;z-index:300;display:flex;flex-direction:column;align-items:flex-start;gap:12px;opacity:0;transform:translateY(30px);transition:all .4s;pointer-events:none}
    #npc-container[data-visible="true"]{opacity:1;transform:translateY(0);pointer-events:auto}
    .npc-avatar{width:80px;height:80px;border-radius:50%;background:linear-gradient(135deg,#0ea5e9,#0284c7);display:flex;align-items:center;justify-content:center;box-shadow:0 8px 32px rgba(14,165,233,.4)}
    .npc-avatar[data-speaking="true"]{animation:npcBounce 0.5s ease infinite}
    .npc-avatar-img{font-size:2.8rem}
    @keyframes npcBounce{0%,100%{transform:translateY(0) scale(1)}50%{transform:translateY(-5px) scale(1.05)}}
    .speech-bubble{background:#fff;border-radius:20px;padding:16px 20px;max-width:min(360px,calc(100vw - 120px));max-height:50vh;overflow-y:auto;box-shadow:0 8px 32px rgba(0,0,0,.2);opacity:0;transform:translateY(10px) scale(0.95);transition:all .3s}
    .speech-bubble[data-visible="true"]{opacity:1;transform:translateY(0) scale(1)}
    .speech-bubble-text{font-size:1rem;line-height:1.5;color:#0f172a;white-space:pre-wrap}
    .speech-continue{margin-top:12px;text-align:right;display:none}
    .speech-continue[data-visible="true"]{display:block}
    .speech-continue-btn{background:linear-gradient(135deg,#10b981,#059669);color:#fff;border:none;padding:10px 20px;border-radius:25px;font-size:.9rem;font-weight:600;cursor:pointer}
    /* Skip Speaking Button */
    .speech-skip-btn{background:rgba(100,116,139,.2);color:#64748b;border:1px solid #94a3b8;padding:6px 14px;border-radius:20px;font-size:.8rem;cursor:pointer;margin-top:10px;transition:all .2s}
    .speech-skip-btn:hover{background:rgba(100,116,139,.3);color:#475569}
    /* Vocab Skip Button */
    .vocab-skip-btn{background:transparent;color:#64748b;border:none;padding:8px 16px;font-size:.85rem;cursor:pointer;margin-top:8px;text-decoration:underline}
    .vocab-skip-btn:hover{color:#475569}

    /* Complete */
    .complete-box{background:linear-gradient(135deg,#e0f2fe,#bae6fd);border-radius:20px;padding:32px;text-align:center;margin:20px 0}
    .complete-icon{font-size:4rem;margin-bottom:12px}
    .complete-box h2{color:#0369a1}

    /* Tables */
    .table-wrap{overflow-x:auto;margin:10px 0;border-radius:10px}
    table{width:100%;border-collapse:collapse;font-size:.85rem;background:#fff}
    th,td{padding:10px 12px;border:1px solid var(--border);text-align:left}
    th{background:linear-gradient(135deg,#e0f2fe,#bae6fd);font-weight:600;color:#0369a1}

    /* Writing Phase */
    .writing-timer{background:linear-gradient(135deg,#0c4a6e,#075985);color:#fff;padding:20px;border-radius:16px;text-align:center}
    .writing-timer-time{font-size:3rem;font-weight:700}

    /* Vocab Button */
    .vocab-btn{background:linear-gradient(135deg,#0ea5e9,#0284c7);color:#fff;border:none;padding:14px 28px;border-radius:50px;font-size:1rem;font-weight:600;cursor:pointer}
    .vocab-nav{display:flex;gap:10px;margin-top:16px;justify-content:center}

    /* Confirmation Dialog */
    .confirm-dialog-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:500;display:none;align-items:center;justify-content:center;padding:20px}
    .confirm-dialog-overlay[data-active="true"]{display:flex}
    .confirm-dialog{background:#fff;border-radius:20px;padding:24px;max-width:320px;width:100%;text-align:center;box-shadow:0 20px 60px rgba(0,0,0,.3)}
    .confirm-dialog-title{font-size:1.1rem;font-weight:600;color:#0f172a;margin-bottom:8px}
    .confirm-dialog-message{font-size:.9rem;color:#64748b;margin-bottom:20px}
    .confirm-dialog-buttons{display:flex;gap:10px;justify-content:center}
    .confirm-dialog-btn{padding:12px 24px;border-radius:25px;font-size:.9rem;font-weight:600;cursor:pointer;border:none}
    .confirm-dialog-btn.cancel{background:#f1f5f9;color:#64748b}
    .confirm-dialog-btn.confirm{background:linear-gradient(135deg,#10b981,#059669);color:#fff}

    /* ============ MOBILE COMPACT STYLES ============ */
    @media (max-width: 640px) {
      /* Compact cards */
      .card{padding:10px;margin:8px 0}

      /* Compact timer */
      .timer{padding:12px;margin:8px 0;border-radius:12px}
      .timer-label{font-size:.75rem;margin-bottom:2px}
      .timer-time{font-size:2rem}
      .timer-skip{padding:8px 16px;margin-top:8px}

      /* Compact teacher script */
      .ts-group{padding:6px;margin-bottom:10px}
      .ts-group-header{font-size:.6rem;margin-bottom:4px}
      .ts{padding:5px 8px;margin:3px 0}
      .ts-content{font-size:.75rem}

      /* Compact vocabulary section */
      .vocab-interactive{padding:12px;margin:8px 0;border-radius:12px}
      .vocab-progress{margin-bottom:10px}
      .vocab-progress-dot{width:8px;height:8px}

      /* Compact vocab start state */
      .vocab-start-state{padding:16px;border-radius:12px}
      .vocab-start-icon{font-size:2rem;margin-bottom:8px}
      .vocab-start-title{font-size:1rem;margin-bottom:4px}
      .vocab-start-count{font-size:.85rem;margin-bottom:12px}
      .vocab-start-btn{padding:12px 24px;font-size:1rem}

      /* Compact flashcard */
      .flashcard{padding:20px 16px;min-height:220px;border-radius:16px}
      .flashcard-word{font-size:1.6rem}
      .flashcard-pron{font-size:1rem;margin-bottom:8px}
      .flashcard-meaning{font-size:1.2rem}

      /* Compact quiz */
      .quiz-question{padding:14px;margin-bottom:10px;border-radius:12px}
      .quiz-word{font-size:1.5rem}
      .quiz-options{gap:8px}
      .quiz-option{padding:10px 12px;border-radius:10px}

      /* Compact writing phase */
      .writing-timer{padding:14px;border-radius:12px}
      .writing-timer-time{font-size:2rem}

      /* Compact game */
      .game-container{gap:8px}
      .game-item{padding:10px;min-height:42px;border-radius:8px}

      /* Compact complete box */
      .complete-box{padding:20px;border-radius:16px;margin:12px 0}
      .complete-icon{font-size:3rem;margin-bottom:8px}

      /* Compact tables */
      table{font-size:.8rem}
      th,td{padding:8px 10px}

      /* Compact typography */
      h2{margin:12px 0 6px}
      h3{margin:8px 0 4px}

      /* Compact bottom nav */
      #bottom-nav{padding:16px 12px}
      #main-nav-btn{padding:14px 20px;font-size:1rem}
    }

    /* ========== EXERCISE SYSTEM ========== */
    .exercise-container{background:linear-gradient(135deg,#f0f9ff,#e0f2fe);border-radius:16px;padding:16px;margin:12px 0;border:2px solid #bae6fd}
    .exercise-header{background:linear-gradient(135deg,#8b5cf6,#7c3aed);color:#fff;padding:12px 16px;border-radius:12px;margin-bottom:16px;display:flex;align-items:center;gap:10px}
    .exercise-icon{font-size:1.5rem}
    .exercise-title{flex:1;font-weight:600}
    .exercise-count{font-size:.85rem;opacity:.9}
    .exercise-start{background:#fff;border-radius:16px;padding:24px;text-align:center;box-shadow:0 4px 16px rgba(0,0,0,.08);border:2px dashed #a78bfa}
    .exercise-start-icon{font-size:3rem;margin-bottom:12px}
    .exercise-start-title{font-size:1.1rem;font-weight:600;color:#7c3aed;margin-bottom:8px}
    .exercise-start-desc{font-size:.9rem;color:#64748b;margin-bottom:16px}
    .exercise-start-btn{background:linear-gradient(135deg,#8b5cf6,#7c3aed);color:#fff;border:none;padding:16px 32px;border-radius:50px;font-size:1.1rem;font-weight:600;cursor:pointer;transition:all .2s;box-shadow:0 4px 16px rgba(139,92,246,.4)}
    .exercise-start-btn:hover{transform:scale(1.05)}
    .exercise-loading{text-align:center;padding:32px;color:#64748b}
    .exercise-question{background:#fff;border-radius:16px;padding:20px;margin-bottom:16px;box-shadow:0 4px 12px rgba(0,0,0,.06)}
    .exercise-q-num{font-size:.85rem;color:#8b5cf6;font-weight:600;margin-bottom:8px}
    .exercise-q-text{font-size:1.1rem;font-weight:500;color:#0f172a;margin-bottom:12px}
    .exercise-options{display:flex;flex-direction:column;gap:10px}
    .exercise-option{background:#f8fafc;border:2px solid #e2e8f0;border-radius:12px;padding:14px 16px;cursor:pointer;transition:all .2s;text-align:left;font-size:1rem}
    .exercise-option:hover{border-color:#8b5cf6;background:#f5f3ff}
    .exercise-option[data-selected="true"]{border-color:#8b5cf6;background:#ede9fe}
    .exercise-option[data-result="correct"]{border-color:#10b981;background:#d1fae5}
    .exercise-option[data-result="wrong"]{border-color:#ef4444;background:#fee2e2}
    .exercise-explanation{background:#fef3c7;border-radius:10px;padding:12px;margin-top:12px;font-size:.9rem;color:#92400e;display:none}
    .exercise-explanation[data-visible="true"]{display:block}
    .exercise-progress{display:flex;gap:6px;margin-bottom:16px;flex-wrap:wrap}
    .exercise-progress-dot{width:10px;height:10px;border-radius:50%;background:#cbd5e1;transition:all .3s}
    .exercise-progress-dot[data-status="done"]{background:#10b981}
    .exercise-progress-dot[data-status="wrong"]{background:#ef4444}
    .exercise-progress-dot[data-status="current"]{background:#8b5cf6;transform:scale(1.3);box-shadow:0 0 8px rgba(139,92,246,.5)}
    .exercise-nav{display:flex;gap:10px;margin-top:16px;justify-content:center}
    .exercise-btn{background:linear-gradient(135deg,#8b5cf6,#7c3aed);color:#fff;border:none;padding:14px 28px;border-radius:50px;font-size:1rem;font-weight:600;cursor:pointer;transition:all .2s;box-shadow:0 4px 12px rgba(139,92,246,.3)}
    .exercise-btn:hover{transform:scale(1.05)}
    .exercise-btn.secondary{background:transparent;color:#7c3aed;border:2px solid #8b5cf6;box-shadow:none}
    .exercise-result{background:#fff;border-radius:16px;padding:24px;text-align:center;box-shadow:0 4px 16px rgba(0,0,0,.08)}
    .exercise-result-icon{font-size:3rem;margin-bottom:12px}
    .exercise-result-score{font-size:1.5rem;font-weight:700;color:#7c3aed;margin-bottom:8px}
    .exercise-result-text{color:#64748b}
    .exercise-completed{opacity:.7;pointer-events:none}
    .exercise-start-btn.secondary{background:transparent;color:#7c3aed;border:2px solid #8b5cf6}

    /* Exercise Modal (iframe) */
    .exercise-modal{position:fixed;inset:0;z-index:10000;background:rgba(0,0,0,.8);display:flex;align-items:center;justify-content:center;padding:16px}
    .exercise-modal-content{width:100%;max-width:900px;height:90vh;max-height:800px;background:#fff;border-radius:16px;overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,.3)}
    .exercise-iframe{width:100%;height:100%;border:none}

    /* Word Rearrange Exercise Type */
    .word-bank{display:flex;flex-wrap:wrap;gap:8px;margin:12px 0;min-height:50px;padding:12px;background:#f1f5f9;border-radius:12px;border:2px dashed #cbd5e1}
    .word-chip{background:linear-gradient(135deg,#8b5cf6,#7c3aed);color:#fff;padding:10px 16px;border-radius:8px;cursor:pointer;font-size:1rem;user-select:none;transition:all .2s;box-shadow:0 2px 8px rgba(139,92,246,.3)}
    .word-chip:hover{transform:scale(1.05)}
    .word-chip[data-selected="true"]{opacity:.4;cursor:not-allowed}
    .word-chip.distractor{background:linear-gradient(135deg,#94a3b8,#64748b)}
    .answer-area{display:flex;flex-wrap:wrap;gap:8px;margin:12px 0;min-height:60px;padding:16px;background:#e0f2fe;border-radius:12px;border:2px solid #7dd3fc}
    .answer-area .word-chip{background:#0ea5e9;cursor:pointer}
    .answer-area .word-chip:hover{background:#0284c7}
    .exercise-instruction{font-size:.9rem;color:#64748b;margin-bottom:12px;font-style:italic}
    .exercise-check-btn{background:linear-gradient(135deg,#10b981,#059669);color:#fff;border:none;padding:12px 24px;border-radius:25px;font-size:1rem;font-weight:600;cursor:pointer;margin-top:12px;transition:all .2s}
    .exercise-check-btn:hover{transform:scale(1.05)}
    .exercise-check-btn:disabled{background:#cbd5e1;cursor:not-allowed;transform:none}
    .answer-correct{border-color:#10b981;background:#d1fae5}
    .answer-wrong{border-color:#ef4444;background:#fee2e2}

    /* Camera gate - Ocean theme */
    #gate{position:fixed;inset:0;background:linear-gradient(135deg,#0c4a6e,#0369a1,#0ea5e9);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:1000;padding:20px}
    #gate.hidden{display:none}
    #gate h1{color:#fff;margin-bottom:8px;font-size:1.5rem}
    #gate p{color:rgba(255,255,255,.9);margin-bottom:16px;text-align:center}
    #gate video,#gate img{width:100%;max-width:240px;aspect-ratio:4/3;object-fit:cover;border-radius:14px;background:#000;border:3px solid rgba(255,255,255,.3)}
    .gate-input{width:100%;max-width:240px;padding:14px;border:2px solid rgba(255,255,255,.4);border-radius:12px;background:rgba(255,255,255,.15);color:#fff;font-size:1rem;margin:12px 0;text-align:center}
    .gate-input::placeholder{color:rgba(255,255,255,.7)}
    .gate-btn{background:#fff;color:#0369a1;border:none;padding:14px 28px;border-radius:50px;font-size:1rem;font-weight:600;cursor:pointer;margin:4px;box-shadow:0 4px 12px rgba(0,0,0,.15);transition:transform .2s}
    .gate-btn:hover{transform:scale(1.05)}
    .gate-btn.secondary{background:transparent;color:#fff;border:2px solid rgba(255,255,255,.5);box-shadow:none}

    /* Sending indicator */
    .sending{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(135deg,#0c4a6e,#075985);color:#fff;padding:18px 32px;border-radius:16px;z-index:1001;display:none;box-shadow:0 8px 24px rgba(0,0,0,.3)}
    .sending.active{display:flex;align-items:center;gap:12px}
    .spinner{width:22px;height:22px;border:3px solid rgba(255,255,255,.3);border-top-color:#fff;border-radius:50%;animation:spin .8s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* Action buttons (record, photo) */
    .action-row{margin:12px 0}
    .action-btn{display:inline-flex;align-items:center;gap:8px;background:#fff;border:2px solid #0ea5e9;color:#0284c7;padding:12px 20px;border-radius:25px;font-size:1rem;font-weight:600;cursor:pointer;transition:all .2s;box-shadow:0 2px 8px rgba(14,165,233,.15)}
    .action-btn:hover{background:#e0f2fe;transform:scale(1.02)}
    .action-btn svg{flex-shrink:0}
    .action-btn.recording{border-color:#ef4444;background:linear-gradient(135deg,#fef2f2,#fee2e2);animation:recordPulse 1s infinite;color:#dc2626}
    @keyframes recordPulse{50%{opacity:.7}}
    .audio-box{background:linear-gradient(135deg,#0c4a6e,#075985);padding:14px;border-radius:12px;margin:12px 0;box-shadow:0 4px 12px rgba(12,74,110,.2)}
    .audio-box audio{width:100%;border-radius:8px}
    .audio-placeholder{background:rgba(255,255,255,.1);color:#bae6fd;padding:18px;border-radius:8px;text-align:center;font-size:.9rem}
  </style>
</head>
<body>
  <!-- Attendance Gate -->
  <div id="gate">
    <h1>ƒêi·ªÉm danh</h1>
    <p>Nh·∫≠p t√™n v√† ch·ª•p ·∫£nh ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
    <input type="text" id="student-name" class="gate-input" placeholder="T√™n c·ªßa b·∫°n...">
    <video id="cam-video" autoplay playsinline muted></video>
    <div style="margin-top:12px">
      <button class="gate-btn" id="capture-btn" disabled>Ch·ª•p ·∫£nh</button>
      <button class="gate-btn secondary" id="skip-btn">B·ªè qua</button>
    </div>
  </div>
  <div class="sending" id="sending"><div class="spinner"></div> ƒêang g·ª≠i...</div>
  <canvas id="canvas" style="display:none"></canvas>

  <!-- Test Mode Banner -->
  <div class="test-banner hidden" id="test-banner" data-testid="test-banner">
    üß™ TEST MODE - Timers: <span id="time-scale">1</span>x | <button onclick="window.__voiceLecture.setTimerScale(1000)">Instant</button>
  </div>

  <header data-testid="header">
    <h1 id="title" data-testid="title">Voice Lecture v2</h1>
    <div class="slide-counter" id="slide-counter" data-testid="slide-counter">B√†i 1/1</div>
    <div id="progress" data-testid="progress">
      <div id="progress-fill" data-testid="progress-fill"></div>
    </div>
  </header>

  <div id="content" data-testid="content"></div>

  <!-- Fixed Bottom Navigation -->
  <div id="bottom-nav" data-testid="bottom-nav">
    <div class="nav-inner">
      <button id="main-nav-btn" data-testid="main-nav-btn" data-ready="false" onclick="window.__voiceLecture?.handleMainNavClick()">
        B·∫Øt ƒë·∫ßu b√†i h·ªçc
      </button>
    </div>
  </div>

  <!-- NPC System -->
  <div id="npc-overlay" data-testid="npc-overlay" data-active="false"></div>
  <div id="npc-container" data-testid="npc-container" data-visible="false">
    <div class="speech-bubble" id="speech-bubble" data-testid="speech-bubble" data-visible="false">
      <div class="speech-bubble-text" id="speech-text" data-testid="speech-text"></div>
      <button class="speech-skip-btn" id="skip-speaking-btn" data-testid="skip-speaking-btn" onclick="window.__voiceLecture?.skipSpeaking()">B·ªè qua</button>
      <div class="speech-continue" id="speech-continue" data-testid="speech-continue" data-visible="false">
        <button class="speech-continue-btn" data-testid="speech-continue-btn" onclick="window.__voiceLecture?.npcContinue()">Ti·∫øp t·ª•c ‚Üí</button>
      </div>
    </div>
    <div class="npc-avatar" id="npc-avatar" data-testid="npc-avatar" data-speaking="false">
      <span class="npc-avatar-img">üë®‚Äçüè´</span>
    </div>
  </div>

  <!-- Confirmation Dialog -->
  <div id="confirm-dialog-overlay" class="confirm-dialog-overlay" data-active="false">
    <div class="confirm-dialog">
      <div class="confirm-dialog-title" id="confirm-dialog-title">X√°c nh·∫≠n</div>
      <div class="confirm-dialog-message" id="confirm-dialog-message">B·∫°n c√≥ ch·∫Øc mu·ªën ti·∫øp t·ª•c?</div>
      <div class="confirm-dialog-buttons">
        <button class="confirm-dialog-btn cancel" onclick="window.__voiceLecture?.confirmDialogCancel()">Ch∆∞a</button>
        <button class="confirm-dialog-btn confirm" onclick="window.__voiceLecture?.confirmDialogConfirm()">C√≥, ti·∫øp t·ª•c</button>
      </div>
    </div>
  </div>

<script type="module">
// ============ CONFIGURATION ============
const params = new URLSearchParams(location.search);
const CONFIG = {
  testMode: params.has('test'),
  timeScale: parseFloat(params.get('speed')) || 1,
  instantTimers: params.get('speed') === 'instant',
  contentUrl: null,
  contentBasePath: null, // Base path for resolving relative audio URLs
  tgToken: params.get('token') || params.get('tg_token'),
  tgChat: params.get('chat') || params.get('tg_chat'),
  skip: params.get('skip') === '1',
};

// Decode content URL and extract base path for audio resolution
const c = params.get('c');
if (c) {
  try {
    CONFIG.contentUrl = decodeURIComponent(atob(c));
  } catch {
    CONFIG.contentUrl = decodeURIComponent(c);
  }
  // Extract base path for relative audio URLs
  // Audio files are in /v2/audio/ relative to site root
  // Content URL format: data/voice-lectures/... or v2/data/voice-lectures/...
  const contentUrl = CONFIG.contentUrl;
  if (contentUrl.includes('data/voice-lectures/')) {
    // Find the base that contains the audio folder (parent of data folder)
    const dataIndex = contentUrl.indexOf('data/voice-lectures/');
    CONFIG.audioBasePath = contentUrl.substring(0, dataIndex) + 'audio/';
  } else {
    // Fallback: extract directory from content URL
    const lastSlash = contentUrl.lastIndexOf('/');
    CONFIG.audioBasePath = lastSlash >= 0 ? contentUrl.substring(0, lastSlash + 1) : '';
  }
}

// Show test banner if in test mode
if (CONFIG.testMode) {
  document.body.classList.add('test-mode');
  document.getElementById('test-banner').classList.remove('hidden');
  document.getElementById('time-scale').textContent = CONFIG.instantTimers ? '‚àû' : CONFIG.timeScale;
}

// ============ SIMPLE MODULAR IMPLEMENTATION ============
// Inline implementation that mirrors the modular structure but works directly in browser

// Event Bus
const eventBus = {
  listeners: new Map(),
  history: [],

  on(event, callback) {
    if (!this.listeners.has(event)) this.listeners.set(event, new Set());
    this.listeners.get(event).add(callback);
    return () => this.off(event, callback);
  },

  off(event, callback) {
    this.listeners.get(event)?.delete(callback);
  },

  emit(event, data) {
    if (CONFIG.testMode) this.history.push({ event, data, timestamp: Date.now() });
    this.listeners.get(event)?.forEach(cb => cb(data));
    window.dispatchEvent(new CustomEvent(`lecture:${event}`, { detail: data }));
  },

  once(event, callback) {
    const wrapper = (data) => { this.off(event, wrapper); callback(data); };
    return this.on(event, wrapper);
  }
};

// Confirmation Dialog System
const confirmDialog = {
  pendingCallback: null,

  show(title, message) {
    return new Promise((resolve) => {
      document.getElementById('confirm-dialog-title').textContent = title;
      document.getElementById('confirm-dialog-message').textContent = message;
      document.getElementById('confirm-dialog-overlay').dataset.active = 'true';
      this.pendingCallback = resolve;
    });
  },

  confirm() {
    document.getElementById('confirm-dialog-overlay').dataset.active = 'false';
    if (this.pendingCallback) {
      this.pendingCallback(true);
      this.pendingCallback = null;
    }
  },

  cancel() {
    document.getElementById('confirm-dialog-overlay').dataset.active = 'false';
    if (this.pendingCallback) {
      this.pendingCallback(false);
      this.pendingCallback = null;
    }
  }
};

// Vocab abort signal for cancelling flashcard loops
const vocabAbortController = {
  aborted: new Set(),

  abort(id) {
    this.aborted.add(id);
  },

  isAborted(id) {
    return this.aborted.has(id);
  },

  reset(id) {
    this.aborted.delete(id);
  }
};

// State
const state = {
  currentState: 'idle',
  currentChunk: 0,
  currentTSId: null,
  chunks: [],
  title: '',

  getState() { return this.currentState; },
  setState(s) { this.currentState = s; eventBus.emit('state:change', { state: s }); },

  getData() {
    return {
      state: this.currentState,
      currentChunkIndex: this.currentChunk,
      currentTSId: this.currentTSId,
      chunkCount: this.chunks.length,
    };
  }
};

// Exercise State - tracks exercise instances
const exerciseState = {
  instances: {}, // {exId: {source, count, exercises, currentQ, answers}}
  counter: 0
};

// Timer Service
const timerService = {
  timers: new Map(),
  timeScale: CONFIG.instantTimers ? 1000 : CONFIG.timeScale,

  start(id, seconds, callback) {
    this.stop(id);
    if (CONFIG.instantTimers) {
      setTimeout(callback, 10);
      return;
    }

    const interval = 1000 / this.timeScale;
    let remaining = seconds;

    const timer = setInterval(() => {
      remaining--;
      eventBus.emit('timer:tick', { id, remaining, total: seconds });
      updateTimerUI(id, remaining);

      if (remaining <= 0) {
        this.stop(id);
        eventBus.emit('timer:end', { id });
        callback();
      }
    }, interval);

    this.timers.set(id, { interval: timer, remaining, callback });
    eventBus.emit('timer:start', { id, seconds });
  },

  stop(id) {
    const timer = this.timers.get(id);
    if (timer) {
      clearInterval(timer.interval);
      this.timers.delete(id);
    }
  },

  skip(id) {
    const timer = this.timers.get(id);
    if (timer) {
      const cb = timer.callback;
      this.stop(id);
      eventBus.emit('timer:skip', { id });
      cb();
    }
  },

  setTimeScale(scale) {
    this.timeScale = scale;
    document.getElementById('time-scale').textContent = scale >= 1000 ? '‚àû' : scale;
  },

  formatTime(s) {
    const m = Math.floor(s / 60);
    return m > 0 ? `${m}:${(s % 60).toString().padStart(2, '0')}` : `${s}s`;
  }
};

// Audio Service
const audioService = {
  skipped: false,
  currentAudio: null,

  async speakTTS(text, lang = 'vi-VN') {
    this.skipped = false;
    eventBus.emit('tts:speak', { text, lang });

    if (CONFIG.testMode && CONFIG.instantTimers) {
      await delay(10);
      if (this.skipped) return { skipped: true };
      eventBus.emit('tts:end', { text, lang });
      return { skipped: false };
    }

    if (!('speechSynthesis' in window)) {
      eventBus.emit('tts:end', { text, lang });
      return { skipped: false };
    }

    return new Promise(resolve => {
      speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.lang = lang;
      u.rate = lang === 'vi-VN' ? 1 : 0.85;
      u.onend = () => {
        if (this.skipped) { resolve({ skipped: true }); return; }
        eventBus.emit('tts:end', { text, lang });
        resolve({ skipped: false });
      };
      u.onerror = () => resolve({ skipped: this.skipped });
      speechSynthesis.speak(u);
    });
  },

  async playBeep(freq = 880, duration = 150) {
    if (CONFIG.testMode && CONFIG.instantTimers) return delay(1);

    return new Promise(resolve => {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.3, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration/1000);
        osc.start();
        osc.stop(ctx.currentTime + duration/1000);
        setTimeout(resolve, duration);
      } catch { resolve(); }
    });
  },

  async playRepeatSignal() {
    await this.playBeep(880, 100);
    await delay(80);
    await this.playBeep(1100, 100);
  },

  async playAudioFile(url) {
    this.skipped = false;
    if (CONFIG.testMode && CONFIG.instantTimers) return delay(10);

    return new Promise((resolve, reject) => {
      const audio = new Audio(url);
      this.currentAudio = audio;
      audio.onended = () => {
        this.currentAudio = null;
        if (this.skipped) { resolve({ skipped: true }); return; }
        resolve({ skipped: false });
      };
      audio.onerror = () => {
        this.currentAudio = null;
        reject(new Error('Audio playback failed'));
      };
      audio.play().catch(reject);
    });
  },

  stop() {
    this.skipped = true;
    if ('speechSynthesis' in window) {
      speechSynthesis.cancel();
    }
    if (this.currentAudio) {
      this.currentAudio.pause();
      this.currentAudio = null;
    }
  }
};

function delay(ms) {
  if (CONFIG.testMode && CONFIG.instantTimers) return Promise.resolve();
  return new Promise(r => setTimeout(r, ms));
}

// Resolve relative paths (handles ../ segments, preserves URL protocol)
function resolveRelativePath(basePath, relativePath) {
  // Preserve URL protocol (https://, http://) if present
  let protocol = '';
  const protocolMatch = basePath.match(/^(https?:\/\/)/);
  if (protocolMatch) {
    protocol = protocolMatch[1];
    basePath = basePath.substring(protocol.length);
  }

  // Split paths into segments
  const baseSegments = basePath.split('/').filter(s => s);
  const relativeSegments = relativePath.split('/');

  // Process relative path segments
  for (const segment of relativeSegments) {
    if (segment === '..') {
      baseSegments.pop(); // Go up one directory
    } else if (segment !== '.' && segment !== '') {
      baseSegments.push(segment);
    }
  }

  return protocol + baseSegments.join('/');
}

// ============ PARSER ============
function parseLesson(md) {
  const titleMatch = md.match(/^#\s+(.+)$/m);
  const title = titleMatch ? titleMatch[1] : 'Voice Lecture';

  const parts = md.split(/(?=<!--\s*chunk:)/);
  const chunks = parts.map((part, index) => {
    const nameMatch = part.match(/<!--\s*chunk:\s*(\w+)/);
    const h3Match = part.match(/^###\s+(.+)$/m);
    const content = part.replace(/<!--\s*chunk:.*?-->/gs, '').replace(/\n---\n/g, '\n').trim();

    return {
      id: nameMatch ? nameMatch[1] : `chunk-${index}`,
      index,
      title: h3Match ? h3Match[1] : (nameMatch ? nameMatch[1] : ''),
      content
    };
  }).filter(c => c.content.length > 20);

  return { title, chunks };
}

function parseVocabulary(content) {
  const words = [];
  content.trim().split(/\r?\n/).forEach(line => {
    const match = line.match(/^\d+\.\s*\*\*(.+?)\*\*\s*:\s*(.+)$/);
    if (match) {
      const word = match[1];
      let rest = match[2].trim();

      let type = null;
      const typeMatch = rest.match(/^\(([^)]+)\)\s*/);
      if (typeMatch) { type = typeMatch[1]; rest = rest.slice(typeMatch[0].length); }

      let pron = null;
      const pronMatch = rest.match(/\s*\/([^\/]+)\/$/);
      if (pronMatch) { pron = pronMatch[1]; rest = rest.slice(0, -pronMatch[0].length); }

      const meaning = rest.trim();
      if (word && meaning) words.push({ word, type, pron, meaning });
    }
  });
  return words;
}

// ============ RENDERER ============
function renderChunks(chunks) {
  const content = document.getElementById('content');

  let html = '';
  chunks.forEach((chunk, i) => {
    html += `<div class="chunk" id="chunk-${i}" data-testid="chunk-${i}" data-index="${i}" data-status="pending">`;
    if (chunk.title) html += `<div class="chunk-title" data-testid="chunk-title-${i}">${chunk.title}</div>`;
    html += renderContent(chunk.content, i);
    html += `</div>`;
  });

  content.innerHTML = html;

  // Update slide counter
  updateSlideCounter();
}

let tsCounter = 0;
let vocabCounter = 0;

function renderContent(md, chunkIndex) {
  let h = md;

  // ===== STEP 1: Extract all teacher scripts first =====
  const teacherScripts = [];
  const tsRegex = /<teacher_script([^>]*)>([\s\S]*?)<\/teacher_script>/gi;
  let tsMatch;
  while ((tsMatch = tsRegex.exec(md)) !== null) {
    const attrs = tsMatch[1];
    const text = tsMatch[2];
    const pause = (attrs.match(/pause="(\d+)"/) || [])[1] || '0';
    const href = (attrs.match(/href="([^"]+)"/) || [])[1] || '';
    const action = (attrs.match(/action="(\w+)"/) || [])[1] || '';
    const id = `ts-${tsCounter++}`;
    const displayText = text.trim().replace(/<\/?(?:eng|vn)>/gi, '').replace(/"/g, '&quot;');

    teacherScripts.push({ id, displayText, pause, href, action });
  }

  // Remove teacher scripts from content (they'll be rendered at top)
  h = h.replace(/<teacher_script([^>]*)>([\s\S]*?)<\/teacher_script>/gi, '');

  // ===== STEP 2: Build grouped teacher scripts at top =====
  let tsGroupHtml = '';
  if (teacherScripts.length > 0) {
    const tsItems = teacherScripts.map(ts => {
      // Truncate long text for compact display
      const shortText = ts.displayText.length > 60
        ? ts.displayText.substring(0, 57) + '...'
        : ts.displayText;

      return `<div class="ts" id="${ts.id}" data-testid="ts-${ts.id}" data-text="${ts.displayText}" data-pause="${ts.pause}" data-href="${ts.href}" data-action="${ts.action}" data-status="pending">
        <div class="ts-content" title="${ts.displayText}">${shortText}</div>
      </div>`;
    }).join('');

    tsGroupHtml = `<div class="ts-group" data-testid="ts-group-${chunkIndex}">
      <div class="ts-group-header">H∆∞·ªõng d·∫´n c·ªßa th·∫ßy</div>
      ${tsItems}
    </div>`;
  }

  // ===== STEP 3: Render other content =====
  // Use HTML comments as placeholders (marked preserves them)
  const placeholders = [];
  const placeholder = (html) => {
    const id = placeholders.length;
    placeholders.push(html);
    return `<!--PH${id}-->`;
  };

  // Vocabulary
  h = h.replace(/<vocabulary>([\s\S]*?)<\/vocabulary>/gi, (_, content) => {
    const vocabId = `vocab-${vocabCounter++}`;
    const words = parseVocabulary(content);
    if (words.length === 0) return '';

    window.__vocabData = window.__vocabData || {};
    window.__vocabData[vocabId] = { words, phase: 'flashcard', currentWord: 0 };

    return placeholder(buildVocabHTML(vocabId, words));
  });

  // Other tags - render content with marked, store as placeholder
  h = h.replace(/<task>([\s\S]*?)<\/task>/gi, (_, c) =>
    placeholder(`<div class="card task-box" data-testid="task">${renderMD(c)}</div>`));
  h = h.replace(/<answer>([\s\S]*?)<\/answer>/gi, (_, c) =>
    placeholder(`<div class="card answer-box" data-testid="answer">${renderMD(c)}</div>`));
  h = h.replace(/<grammar>([\s\S]*?)<\/grammar>/gi, (_, c) =>
    placeholder(`<div class="card grammar-box" data-testid="grammar">${renderMD(c)}</div>`));
  h = h.replace(/<dialogue>([\s\S]*?)<\/dialogue>/gi, (_, c) =>
    placeholder(`<div class="card dialogue-box" data-testid="dialogue">${renderMD(c)}</div>`));
  h = h.replace(/<translation>([\s\S]*?)<\/translation>/gi, (_, c) =>
    placeholder(`<div class="card" data-testid="translation">${renderMD(c)}</div>`));
  h = h.replace(/<reading>([\s\S]*?)<\/reading>/gi, (_, c) =>
    placeholder(`<div class="card" data-testid="reading">${renderMD(c)}</div>`));
  h = h.replace(/<questions[^>]*>([\s\S]*?)<\/questions>/gi, (_, c) =>
    placeholder(`<div class="card" data-testid="questions">${renderMD(c)}</div>`));
  h = h.replace(/<explanation>([\s\S]*?)<\/explanation>/gi, (_, c) =>
    placeholder(`<div class="card" data-testid="explanation">${renderMD(c)}</div>`));

  // Audio tag - external listening audio
  h = h.replace(/<audio\s+src="([^"]*)"[^>]*>([\s\S]*?)<\/audio>/gi, (_, src, label) => {
    const audioHtml = src.includes('TODO')
      ? `<div class="audio-box"><div class="audio-placeholder">üîá ${label || 'Audio ch∆∞a s·∫µn s√†ng'}</div></div>`
      : `<div class="audio-box"><audio controls src="${src}"></audio></div>`;
    return placeholder(audioHtml);
  });

  // Exercise tag - interactive exercise from JSON
  h = h.replace(/<exercise([^>]*)>([\s\S]*?)<\/exercise>/gi, (_, attrs, content) => {
    const source = (attrs.match(/data-source="([^"]+)"/) || [])[1] || '';
    const countMatch = (attrs.match(/data-count="(\d+)"/) || [])[1];
    const exId = `ex-${exerciseState.counter++}`;
    exerciseState.instances[exId] = {
      source,
      count: countMatch ? parseInt(countMatch) : null,
      exercises: [],
      currentQ: 0,
      answers: []
    };
    return placeholder(buildExerciseContainer(exId, content.trim(), source, countMatch));
  });

  // Render remaining markdown (headings outside tags)
  let result = renderMD(h);

  // Restore placeholders
  placeholders.forEach((html, i) => {
    result = result.replace(`<!--PH${i}-->`, html);
  });

  // Render timers after content (they appear when teacher script with pause is played)
  let timersHtml = '';
  teacherScripts.forEach(ts => {
    if (parseInt(ts.pause) > 0) {
      timersHtml += `
        <div class="timer" id="${ts.id}-timer" data-testid="timer-${ts.id}" data-active="false">
          <div class="timer-label">Th·ªùi gian l√†m b√†i</div>
          <div class="timer-time" data-testid="timer-time-${ts.id}">${timerService.formatTime(parseInt(ts.pause))}</div>
          <button class="timer-skip" data-testid="timer-skip-${ts.id}" onclick="window.__voiceLecture.skipTimer('${ts.id}')">Xong r·ªìi ‚Üí</button>
        </div>`;
    }
    if (ts.action === 'record') {
      timersHtml += `<div class="action-row" data-testid="action-record-${ts.id}">
        <button class="action-btn" id="${ts.id}-rec" onclick="window.toggleRec('${ts.id}')">
          <svg viewBox="0 0 24 24" fill="currentColor" width="22" height="22">
            <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5-3c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
          </svg>
          <span>Ghi √¢m</span>
        </button>
      </div><div id="${ts.id}-player"></div>`;
    }
  });

  // Return: ts-group at top, then content, then timers at bottom
  return tsGroupHtml + result + timersHtml;
}

function renderMD(md) {
  // Configure marked for GFM tables
  if (typeof marked !== 'undefined' && marked.parse) {
    try {
      marked.setOptions({
        gfm: true,
        breaks: true
      });

      // Wrap tables in .table-wrap div for scrolling
      const html = marked.parse(md);
      return html.replace(/<table>/g, '<div class="table-wrap"><table>')
                 .replace(/<\/table>/g, '</table></div>');
    } catch (e) {
      console.warn('marked.parse failed, using fallback:', e);
    }
  }

  // Fallback if marked not loaded or failed
  let h = md;
  h = h.replace(/^###\s+(.+)$/gm, '<h3>$1</h3>');
  h = h.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
  h = h.replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');
  // Bold: **text** (can be in middle of words)
  h = h.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  // Italic: *text*
  h = h.replace(/\*([^*]+)\*/g, '<em>$1</em>');
  h = h.replace(/^-\s+(.+)$/gm, '<li>$1</li>');
  h = h.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');
  // Tables - simple handling
  h = h.replace(/^\|(.+)\|$/gm, (match, content) => {
    const cells = content.split('|').map(c => c.trim());
    return '<tr>' + cells.map(c => `<td>${c}</td>`).join('') + '</tr>';
  });
  h = h.replace(/(<tr>.*<\/tr>\n?)+/g, '<div class="table-wrap"><table>$&</table></div>');
  // Remove separator rows
  h = h.replace(/<tr><td>[-:\s]+<\/td>.*?<\/tr>/g, '');
  h = h.replace(/\n\n+/g, '</p><p>');
  h = h.replace(/\n/g, '<br>');
  return h;
}

function buildVocabHTML(id, words) {
  const dots = words.map((_, i) => `<div class="vocab-progress-dot" data-testid="${id}-dot-${i}" data-status="pending"></div>`).join('');

  return `
<div class="vocab-interactive" id="${id}" data-testid="${id}" data-status="active" data-phase="flashcard">
  <div class="vocab-progress">${dots}</div>

  <div class="vocab-phase" id="${id}-phase-flashcard" data-testid="${id}-phase-flashcard" data-active="true" data-learning="false">
    <!-- Start State - Compact -->
    <div class="vocab-start-state" id="${id}-start-state" data-testid="${id}-start-state">
      <div class="vocab-start-icon">üìö</div>
      <div class="vocab-start-title">T·ª´ v·ª±ng Unit n√†y</div>
      <div class="vocab-start-count">${words.length} t·ª´ c·∫ßn h·ªçc</div>
      <button class="vocab-start-btn" data-testid="${id}-start-btn" onclick="window.__voiceLecture.startVocabFlashcard('${id}')">B·∫•m v√¥ ƒë·ªÉ h·ªçc t·ª´ v·ª±ng</button>
      <button class="vocab-skip-btn" data-testid="${id}-skip-btn" onclick="window.__voiceLecture.skipVocab('${id}')">B·ªè qua t·ª´ v·ª±ng</button>
    </div>

    <!-- Learning State - Full flashcard (hidden initially) -->
    <div class="vocab-learning-state" id="${id}-learning-state" data-testid="${id}-learning-state">
      <div class="phase-header"><span>üé¥</span> H·ªçc t·ª´ v·ª±ng - T·ª´ <span id="${id}-fc-num" data-testid="${id}-word-num">1</span>/${words.length}</div>
      <div class="flashcard" id="${id}-flashcard" data-testid="${id}-flashcard" data-flipped="false">
        <div class="flashcard-front">
          <div class="flashcard-word" id="${id}-fc-word" data-testid="${id}-word">${words[0].word}</div>
          <div class="flashcard-pron" id="${id}-fc-pron">${words[0].pron ? '/'+words[0].pron+'/' : ''}</div>
        </div>
        <div class="flashcard-back">
          <div class="flashcard-word" id="${id}-fc-word-back">${words[0].word}</div>
          <div class="flashcard-meaning" id="${id}-fc-meaning" data-testid="${id}-meaning">${words[0].meaning}</div>
        </div>
      </div>
    </div>
  </div>

  <div class="vocab-phase" id="${id}-phase-quiz" data-testid="${id}-phase-quiz" data-active="false">
    <div class="phase-header"><span>‚ùì</span> Ki·ªÉm tra nhanh - C√¢u <span id="${id}-quiz-num">1</span>/${words.length}</div>
    <div class="quiz-question">
      <div class="quiz-prompt" id="${id}-quiz-prompt">Ch·ªçn nghƒ©a ƒë√∫ng:</div>
      <div class="quiz-word" id="${id}-quiz-word" data-testid="${id}-quiz-word">${words[0].word}</div>
    </div>
    <div class="quiz-options" id="${id}-quiz-options" data-testid="${id}-quiz-options"></div>
  </div>

  <div class="vocab-phase" id="${id}-phase-writing" data-testid="${id}-phase-writing" data-active="false">
    <div class="phase-header"><span>‚úçÔ∏è</span> Ghi v√†o t·∫≠p</div>
    <div class="writing-list">${words.map((w,i) => `<div class="writing-item"><span class="writing-num">${i+1}</span> <strong>${w.word}</strong> - ${w.meaning}</div>`).join('')}</div>
    <div class="writing-timer">
      <div id="${id}-writing-time" data-testid="${id}-writing-time">${Math.floor(words.length*30/60)}:${(words.length*30%60).toString().padStart(2,'0')}</div>
    </div>
    <div class="vocab-nav">
      <button class="vocab-btn" data-testid="${id}-skip-writing" onclick="window.__voiceLecture.skipVocabWriting('${id}')">Xong r·ªìi ‚Üí</button>
    </div>
  </div>

  <div class="vocab-phase" id="${id}-phase-game" data-testid="${id}-phase-game" data-active="false">
    <div class="phase-header"><span>üéÆ</span> Game n·ªëi t·ª´ - <span id="${id}-game-score">0</span>/${words.length}</div>
    <div class="game-container" id="${id}-game" data-testid="${id}-game"></div>
  </div>

  <div class="vocab-phase" id="${id}-phase-complete" data-testid="${id}-phase-complete" data-active="false">
    <div class="complete-box" style="margin:0">
      <div class="complete-icon">üéâ</div>
      <h2>Ho√†n th√†nh t·ª´ v·ª±ng!</h2>
    </div>
    <div class="vocab-nav">
      <button class="vocab-btn" data-testid="${id}-finish-btn" onclick="window.__voiceLecture.finishVocab('${id}')">Ti·∫øp t·ª•c b√†i h·ªçc ‚Üí</button>
    </div>
  </div>
</div>`;
}

// ============ EXERCISE SYSTEM ============
// Uses the comprehensive game engine from tieu-hoc via iframe modal

function buildExerciseContainer(id, content, source, count) {
  return `
<div class="exercise-container" id="${id}" data-testid="exercise-${id}">
  <div class="exercise-start" id="${id}-start" data-testid="exercise-start-${id}">
    <div class="exercise-start-icon">üìù</div>
    <div class="exercise-start-title">${content || 'B√†i t·∫≠p th·ª±c h√†nh'}</div>
    <div class="exercise-start-desc">B√†i t·∫≠p t∆∞∆°ng t√°c ƒëa d·∫°ng</div>
    <button class="exercise-start-btn" data-testid="exercise-start-btn-${id}" onclick="window.__voiceLecture.startExercise('${id}')">B·∫Øt ƒë·∫ßu l√†m b√†i</button>
  </div>
</div>`;
}

function startExercise(id) {
  const inst = exerciseState.instances[id];
  if (!inst) return;

  // Resolve the JSON URL
  let jsonUrl = inst.source;
  if (CONFIG.contentUrl && !inst.source.startsWith('http')) {
    const basePath = CONFIG.contentUrl.substring(0, CONFIG.contentUrl.lastIndexOf('/'));
    jsonUrl = resolveRelativePath(basePath, inst.source);
  }

  // Build game wrapper URL
  const gameWrapperUrl = 'tieu-hoc/pages/game-wrapper.html?embedded=true&data=' + encodeURIComponent(jsonUrl);

  eventBus.emit('exercise:start', { id, source: jsonUrl });

  // Open exercise modal
  openExerciseModal(id, gameWrapperUrl);
}

// Exercise modal management
function openExerciseModal(id, url) {
  // Create modal overlay
  const modal = document.createElement('div');
  modal.id = 'exercise-modal';
  modal.className = 'exercise-modal';
  modal.innerHTML = `
    <div class="exercise-modal-content">
      <iframe src="${url}" id="exercise-iframe" class="exercise-iframe"></iframe>
    </div>
  `;
  document.body.appendChild(modal);
  document.body.style.overflow = 'hidden';

  // Store current exercise ID
  exerciseState.currentModalId = id;

  // Listen for messages from iframe
  window.addEventListener('message', handleExerciseMessage);

  eventBus.emit('exercise:modal:open', { id, url });
}

function handleExerciseMessage(event) {
  if (event.data.type === 'exercise-close') {
    closeExerciseModal(false);
  } else if (event.data.type === 'exercise-complete') {
    const results = event.data.results;
    eventBus.emit('exercise:complete', {
      id: exerciseState.currentModalId,
      ...results
    });
    closeExerciseModal(true, results);
  }
}

function closeExerciseModal(completed, results) {
  const modal = document.getElementById('exercise-modal');
  if (modal) {
    modal.remove();
    document.body.style.overflow = '';
  }

  window.removeEventListener('message', handleExerciseMessage);

  const id = exerciseState.currentModalId;

  // Mark exercise as completed if finished
  if (completed && id) {
    const exEl = document.getElementById(id);
    if (exEl) {
      exEl.classList.add('exercise-completed');
      const startEl = document.getElementById(`${id}-start`);
      if (startEl) {
        const pct = results?.percentage || 0;
        startEl.innerHTML = `
          <div class="exercise-start-icon">‚úÖ</div>
          <div class="exercise-start-title">Ho√†n th√†nh!</div>
          <div class="exercise-start-desc">${results?.correctAnswers || 0}/${results?.totalQuestions || 0} c√¢u ƒë√∫ng (${pct}%)</div>
          <button class="exercise-start-btn secondary" onclick="window.__voiceLecture.startExercise('${id}')">L√†m l·∫°i</button>
        `;
      }
    }

    // Resume lecture flow
    setTimeout(() => {
      state.setState('idle');
      playNextTS();
    }, 500);
  }

  exerciseState.currentModalId = null;
  eventBus.emit('exercise:modal:close', { id, completed });
}

// ============ UI UPDATES ============
function updateTimerUI(id, remaining) {
  const timerEl = document.getElementById(`${id}-timer`);
  const timeEl = timerEl?.querySelector('.timer-time');
  if (timeEl) {
    timeEl.textContent = timerService.formatTime(remaining);
    timeEl.dataset.warning = remaining <= 10;
    timeEl.dataset.danger = remaining <= 5;
  }
}

function updateProgress() {
  const pct = ((state.currentChunk + 1) / state.chunks.length) * 100;
  document.getElementById('progress-fill').style.width = pct + '%';
  updateSlideCounter();
}

function updateSlideCounter() {
  const counter = document.getElementById('slide-counter');
  if (counter && state.chunks.length > 0) {
    counter.textContent = `B√†i ${state.currentChunk + 1}/${state.chunks.length}`;
  }
}

function updateMainNavButton(ready, text = null) {
  const btn = document.getElementById('main-nav-btn');
  if (btn) {
    btn.dataset.ready = ready ? 'true' : 'false';
    if (text) btn.textContent = text;
  }
}

function showNPC(text) {
  document.getElementById('npc-overlay').dataset.active = 'true';
  document.getElementById('npc-container').dataset.visible = 'true';
  document.getElementById('speech-bubble').dataset.visible = 'true';
  document.getElementById('npc-avatar').dataset.speaking = 'true';
  // Convert newlines to <br> for proper line breaks in speech bubble
  const formattedText = text.replace(/\n/g, '<br>');
  document.getElementById('speech-text').innerHTML = formattedText;
}

function hideNPC() {
  document.getElementById('npc-overlay').dataset.active = 'false';
  document.getElementById('npc-container').dataset.visible = 'false';
  document.getElementById('speech-bubble').dataset.visible = 'false';
  document.getElementById('npc-avatar').dataset.speaking = 'false';
}

// ============ LECTURE FLOW ============
function activateChunk(index) {
  if (index >= state.chunks.length) return;

  state.currentChunk = index;
  state.setState('idle');

  // Slide-based: only show active chunk
  document.querySelectorAll('.chunk').forEach((el, i) => {
    el.dataset.status = i < index ? 'completed' : i === index ? 'active' : 'pending';
    // Reset all teacher scripts in this chunk to pending
    if (i === index) {
      el.querySelectorAll('.ts').forEach(ts => {
        ts.dataset.status = 'pending';
      });
    }
  });

  // Disable nav button while chunk is playing
  updateMainNavButton(false, index === 0 ? 'ƒêang t·∫£i...' : 'ƒêang h·ªçc...');

  const chunk = document.getElementById(`chunk-${index}`);
  if (chunk) {
    // Scroll to top of the slide
    window.scrollTo({ top: 0, behavior: 'smooth' });
    // Start playing teacher scripts after a short delay
    setTimeout(() => playNextTS(), 400);
  }

  updateProgress();
  eventBus.emit('chunk:activate', { index });
}

function playNextTS() {
  const chunkEl = document.getElementById(`chunk-${state.currentChunk}`);
  if (!chunkEl) {
    unlockChunkNav();
    return;
  }

  // Find next teacher script that hasn't been played
  const nextTS = chunkEl.querySelector('.ts[data-status="pending"]');
  if (nextTS) {
    playTS(nextTS);
  } else {
    // No more teacher scripts - check for vocab that needs to start
    const pendingVocab = chunkEl.querySelector('.vocab-interactive[data-status="active"]');
    if (pendingVocab) {
      state.setState('vocab');
      eventBus.emit('vocab:ready', { id: pendingVocab.id });
      // Wait for user to click start
    } else {
      unlockChunkNav();
    }
  }
}

function playTS(el) {
  if (state.getState() === 'npc_speaking') return;

  state.setState('npc_speaking');
  state.currentTSId = el.id;

  // Set status to speaking (highlight)
  el.dataset.status = 'speaking';

  // Scroll the TS into view nicely
  el.scrollIntoView({ behavior: 'smooth', block: 'center' });

  const text = el.dataset.text;
  const pause = parseInt(el.dataset.pause) || 0;

  showNPC(text);
  eventBus.emit('ts:start', { id: el.id, text });

  const onEnd = () => {
    document.getElementById('npc-avatar').dataset.speaking = 'false';

    // Mark as played (grayed out)
    el.dataset.status = 'played';

    eventBus.emit('ts:end', { id: el.id });

    if (pause > 0) {
      hideNPC();
      state.setState('timer');

      const timerEl = document.getElementById(`${el.id}-timer`);
      if (timerEl) timerEl.dataset.active = 'true';

      timerService.start(el.id, pause, () => {
        if (timerEl) timerEl.dataset.active = 'false';
        state.setState('idle');
        afterTimer();
      });
    } else {
      afterSpeaking(el);
    }
  };

  const href = el.dataset.href;
  if (href) {
    // Resolve audio URL based on href format
    let audioUrl;
    if (href.startsWith('http') || href.startsWith('/')) {
      // Absolute URL - use as-is
      audioUrl = href;
    } else if (href.startsWith('audio/')) {
      // Relative "audio/xxx.mp3" format - use audioBasePath
      const filename = href.substring(6); // Remove "audio/" prefix
      audioUrl = (CONFIG.audioBasePath || 'audio/') + filename;
    } else {
      // Other relative path - try audioBasePath + href
      audioUrl = (CONFIG.audioBasePath || '') + href;
    }

    // Play mp3 file, fallback to TTS on error
    audioService.playAudioFile(audioUrl).then(result => {
      if (!result?.skipped) onEnd();
    }).catch((err) => {
      console.warn('Audio playback failed, falling back to TTS:', err);
      audioService.speakTTS(text, 'vi-VN').then(result => {
        if (!result?.skipped) onEnd();
      });
    });
  } else {
    audioService.speakTTS(text, 'vi-VN').then(result => {
      if (!result?.skipped) onEnd();
    });
  }
}

function afterSpeaking(tsEl) {
  hideNPC();
  state.setState('idle'); // Reset state so next TS can play

  // Since all TS are grouped at top, just play next pending TS
  // When all TS done, playNextTS will unlock navigation
  setTimeout(() => playNextTS(), 200);
}

function afterTimer() {
  playNextTS();
}

function skipSpeaking() {
  // Stop any TTS or audio playback
  audioService.stop();

  // Find current speaking TS and mark as played
  const speakingTS = document.querySelector('.ts[data-status="speaking"]');
  if (speakingTS) {
    speakingTS.dataset.status = 'played';
    hideNPC();
    state.setState('idle');
    eventBus.emit('ts:skip', { id: speakingTS.id });
    // Continue to next TS
    setTimeout(() => playNextTS(), 200);
  }
}

function unlockChunkNav() {
  state.setState('chunk_done');

  eventBus.emit('chunk:complete', { index: state.currentChunk });

  // Enable the fixed bottom navigation button
  const isLastChunk = state.currentChunk >= state.chunks.length - 1;
  const btnText = isLastChunk ? 'Ho√†n th√†nh b√†i h·ªçc üéâ' : 'Ti·∫øp t·ª•c ‚Üí';
  updateMainNavButton(true, btnText);
}

function advanceToNextChunk() {
  if (state.getState() !== 'chunk_done') return;

  const next = state.currentChunk + 1;
  if (next < state.chunks.length) {
    eventBus.emit('chunk:advance', { from: state.currentChunk, to: next });
    activateChunk(next);
  } else {
    showComplete();
  }
}

function handleMainNavClick() {
  const btn = document.getElementById('main-nav-btn');
  if (btn?.dataset.ready !== 'true') return;

  // If lesson not started yet (first chunk, state is idle before first TS)
  if (state.currentChunk === 0 && state.getState() === 'idle' && !state.currentTSId) {
    // Start the lesson - begin playing teacher scripts
    updateMainNavButton(false, 'ƒêang h·ªçc...');
    state.setState('idle');
    setTimeout(() => playNextTS(), 300);
    return;
  }

  // Otherwise advance to next chunk
  advanceToNextChunk();
}

function showComplete() {
  state.setState('complete');

  // Hide all chunks and show complete box
  document.querySelectorAll('.chunk').forEach(el => {
    el.dataset.status = 'completed';
  });

  document.getElementById('content').innerHTML += `
    <div class="chunk complete-slide" data-status="active">
      <div class="complete-box" data-testid="lesson-complete">
        <div class="complete-icon">üéâ</div>
        <h2>Ho√†n th√†nh b√†i h·ªçc!</h2>
        <p>Gi·ªèi l·∫Øm! V·ªÅ nh√† √¥n l·∫°i t·ª´ v·ª±ng nha.</p>
      </div>
    </div>`;

  // Hide the bottom nav button
  updateMainNavButton(false, 'ƒê√£ ho√†n th√†nh');

  window.scrollTo({ top: 0, behavior: 'smooth' });
  eventBus.emit('lesson:complete', {});
}

// ============ VOCABULARY FLOW ============
async function startVocabFlashcard(id) {
  const data = window.__vocabData[id];
  if (!data) return;

  // Reset abort signal when starting
  vocabAbortController.reset(id);

  data.phase = 'flashcard';
  data.currentWord = 0;

  // Hide start state, show learning state
  const phaseEl = document.getElementById(`${id}-phase-flashcard`);
  if (phaseEl) phaseEl.dataset.learning = 'true';

  eventBus.emit('vocab:flashcard:start', { id });

  await audioService.speakTTS('ƒê·ªçc theo nha!', 'vi-VN');
  if (vocabAbortController.isAborted(id)) return;
  await delay(300);

  for (let i = 0; i < data.words.length; i++) {
    // Check abort at start of each word
    if (vocabAbortController.isAborted(id)) return;

    data.currentWord = i;
    const w = data.words[i];

    // Update UI - both front and back
    document.getElementById(`${id}-fc-num`).textContent = i + 1;
    document.getElementById(`${id}-fc-word`).textContent = w.word;
    document.getElementById(`${id}-fc-pron`).textContent = w.pron ? '/'+w.pron+'/' : '';
    document.getElementById(`${id}-fc-word-back`).textContent = w.word;
    document.getElementById(`${id}-fc-meaning`).textContent = w.meaning;
    document.getElementById(`${id}-flashcard`).dataset.flipped = 'false';

    // Update dots
    document.querySelectorAll(`[data-testid^="${id}-dot-"]`).forEach((dot, di) => {
      dot.dataset.status = di < i ? 'done' : di === i ? 'current' : 'pending';
    });

    eventBus.emit('vocab:word:change', { id, wordIndex: i, word: w });

    // Step 1: Read English word once (introduce the word)
    if (vocabAbortController.isAborted(id)) return;
    await audioService.speakTTS(w.word, 'en-US');
    await delay(400);

    // Flip card to show meaning
    if (vocabAbortController.isAborted(id)) return;
    document.getElementById(`${id}-flashcard`).dataset.flipped = 'true';
    await delay(300);

    // Step 2: Read Vietnamese meaning once (only once to save time)
    if (vocabAbortController.isAborted(id)) return;
    await audioService.speakTTS(w.meaning, 'vi-VN');
    await delay(400);

    // Step 3: Read English word 3x (for student to repeat)
    for (let r = 0; r < 3; r++) {
      if (vocabAbortController.isAborted(id)) return;
      await audioService.playRepeatSignal();
      await delay(200);
      if (vocabAbortController.isAborted(id)) return;
      await audioService.speakTTS(w.word, 'en-US');
      await delay(600); // Time for student to repeat
    }

    if (vocabAbortController.isAborted(id)) return;
    await delay(300);

    if (i < data.words.length - 1) {
      await audioService.speakTTS('T·ª´ ti·∫øp theo', 'vi-VN');
      await delay(300);
    }
  }

  // Check abort before completing
  if (vocabAbortController.isAborted(id)) return;

  // Mark all dots done
  document.querySelectorAll(`[data-testid^="${id}-dot-"]`).forEach(dot => {
    dot.dataset.status = 'done';
  });

  await audioService.speakTTS('Xong ph·∫ßn h·ªçc t·ª´. Gi·ªù ki·ªÉm tra nhanh nha!', 'vi-VN');
  await delay(500);

  startVocabQuiz(id);
}

function shuffle(arr) {
  if (CONFIG.testMode) return arr; // Deterministic for tests
  const result = [...arr];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}

function startVocabQuiz(id) {
  const data = window.__vocabData[id];
  data.phase = 'quiz';
  data.currentWord = 0;
  data.quizAnswers = [];

  document.getElementById(`${id}-phase-flashcard`).dataset.active = 'false';
  document.getElementById(`${id}-phase-quiz`).dataset.active = 'true';
  document.getElementById(id).dataset.phase = 'quiz';

  eventBus.emit('vocab:phase:change', { id, phase: 'quiz' });

  showQuizQuestion(id);
}

async function showQuizQuestion(id) {
  const data = window.__vocabData[id];
  const w = data.words[data.currentWord];

  document.getElementById(`${id}-quiz-num`).textContent = data.currentWord + 1;
  document.getElementById(`${id}-quiz-word`).textContent = w.word;
  document.getElementById(`${id}-quiz-prompt`).textContent = 'Ch·ªçn nghƒ©a ƒë√∫ng:';

  const correct = w.meaning;
  const others = data.words.filter((_, i) => i !== data.currentWord).map(x => x.meaning);
  const options = shuffle([correct, ...shuffle(others).slice(0, 3)]);

  const optContainer = document.getElementById(`${id}-quiz-options`);
  optContainer.innerHTML = options.map(opt =>
    `<div class="quiz-option" data-testid="${id}-option" data-answer="${opt}" onclick="window.__voiceLecture.handleQuizAnswer('${id}', '${opt.replace(/'/g, "\\'")}', '${correct.replace(/'/g, "\\'")}')">${opt}</div>`
  ).join('');

  await audioService.playBeep(660, 100);
  await audioService.speakTTS(`C√¢u ${data.currentWord + 1}.`, 'vi-VN');
  await audioService.speakTTS(w.word, 'en-US');
  await audioService.speakTTS('nghƒ©a l√† g√¨?', 'vi-VN');
}

async function handleQuizAnswer(id, selected, correct) {
  const data = window.__vocabData[id];
  const isCorrect = selected === correct;
  data.quizAnswers.push(isCorrect);

  document.querySelectorAll(`#${id}-quiz-options .quiz-option`).forEach(opt => {
    opt.style.pointerEvents = 'none';
    if (opt.dataset.answer === correct) opt.dataset.result = 'correct';
    if (opt.dataset.answer === selected && !isCorrect) opt.dataset.result = 'wrong';
  });

  eventBus.emit('vocab:quiz:answer', { id, isCorrect, selected, correct });

  if (isCorrect) {
    await audioService.playBeep(880, 150);
    await audioService.playBeep(1100, 200);
    await audioService.speakTTS('ƒê√∫ng r·ªìi!', 'vi-VN');
  } else {
    await audioService.playBeep(300, 300);
    await audioService.speakTTS(`Sai r·ªìi. ƒê√°p √°n ƒë√∫ng l√† ${correct}`, 'vi-VN');
  }

  await delay(2000);

  data.currentWord++;
  if (data.currentWord < data.words.length) {
    showQuizQuestion(id);
  } else {
    startVocabWriting(id);
  }
}

function startVocabWriting(id) {
  const data = window.__vocabData[id];
  data.phase = 'writing';

  document.getElementById(`${id}-phase-quiz`).dataset.active = 'false';
  document.getElementById(`${id}-phase-writing`).dataset.active = 'true';
  document.getElementById(id).dataset.phase = 'writing';

  eventBus.emit('vocab:phase:change', { id, phase: 'writing' });

  const totalSeconds = data.words.length * 30;
  const timeEl = document.getElementById(`${id}-writing-time`);

  data.writingTimerId = `vocab-writing-${id}`;

  let remaining = totalSeconds;
  const updateTime = () => {
    const m = Math.floor(remaining / 60);
    const s = remaining % 60;
    timeEl.textContent = `${m}:${s.toString().padStart(2, '0')}`;
  };

  timerService.start(data.writingTimerId, totalSeconds, () => {
    startVocabGame(id);
  });

  const minutes = Math.ceil(totalSeconds / 60);
  audioService.speakTTS(`Gi·ªù ghi t·ª´ v·ª±ng v√†o t·∫≠p nha. ${minutes} ph√∫t.`, 'vi-VN');
}

function skipVocabWriting(id) {
  const data = window.__vocabData[id];
  timerService.skip(data.writingTimerId);
}

function startVocabGame(id) {
  const data = window.__vocabData[id];
  data.phase = 'game';
  data.gameMatched = 0;
  data.gameSelected = null;

  document.getElementById(`${id}-phase-writing`).dataset.active = 'false';
  document.getElementById(`${id}-phase-game`).dataset.active = 'true';
  document.getElementById(id).dataset.phase = 'game';

  eventBus.emit('vocab:phase:change', { id, phase: 'game' });

  const words = shuffle([...data.words]);
  const meanings = shuffle([...data.words]);

  const gameEl = document.getElementById(`${id}-game`);
  gameEl.innerHTML = `
    <div class="game-col">
      <div class="game-col-title">Ti·∫øng Anh</div>
      ${words.map(w => `<div class="game-item" data-testid="${id}-game-word" data-word="${w.word}" data-type="word" data-matched="false" data-selected="false" onclick="window.__voiceLecture.handleGameSelect('${id}', '${w.word.replace(/'/g, "\\'")}', 'word')">${w.word}</div>`).join('')}
    </div>
    <div class="game-col">
      <div class="game-col-title">Ti·∫øng Vi·ªát</div>
      ${meanings.map(w => `<div class="game-item" data-testid="${id}-game-meaning" data-word="${w.word}" data-type="meaning" data-matched="false" data-selected="false" onclick="window.__voiceLecture.handleGameSelect('${id}', '${w.word.replace(/'/g, "\\'")}', 'meaning')">${w.meaning}</div>`).join('')}
    </div>
  `;

  audioService.speakTTS('Ch∆°i game n·ªëi t·ª´ nha. Ch·ªçn t·ª´ ti·∫øng Anh r·ªìi ch·ªçn nghƒ©a ti·∫øng Vi·ªát.', 'vi-VN');
}

async function handleGameSelect(id, word, type) {
  const data = window.__vocabData[id];

  await audioService.playBeep(500, 50);

  if (!data.gameSelected) {
    data.gameSelected = { word, type };
    document.querySelector(`#${id}-game .game-item[data-word="${word}"][data-type="${type}"]`).dataset.selected = 'true';
    return;
  }

  if (data.gameSelected.type === type) {
    document.querySelector(`#${id}-game .game-item[data-word="${data.gameSelected.word}"][data-type="${data.gameSelected.type}"]`).dataset.selected = 'false';
    data.gameSelected = { word, type };
    document.querySelector(`#${id}-game .game-item[data-word="${word}"][data-type="${type}"]`).dataset.selected = 'true';
    return;
  }

  // Check match
  if (data.gameSelected.word === word) {
    // Match!
    document.querySelector(`#${id}-game .game-item[data-word="${data.gameSelected.word}"][data-type="${data.gameSelected.type}"]`).dataset.matched = 'true';
    document.querySelector(`#${id}-game .game-item[data-word="${word}"][data-type="${type}"]`).dataset.matched = 'true';
    document.querySelector(`#${id}-game .game-item[data-word="${data.gameSelected.word}"][data-type="${data.gameSelected.type}"]`).dataset.selected = 'false';

    data.gameMatched++;
    document.getElementById(`${id}-game-score`).textContent = data.gameMatched;

    await audioService.playBeep(660, 100);
    await audioService.playBeep(880, 100);
    await audioService.playBeep(1100, 150);

    eventBus.emit('vocab:game:match', { id, word, matched: data.gameMatched });

    if (data.gameMatched === data.words.length) {
      await delay(500);
      await audioService.speakTTS('Xu·∫•t s·∫Øc! N·ªëi ƒë√∫ng h·∫øt r·ªìi!', 'vi-VN');
      await delay(1000);
      completeVocab(id);
    }
  } else {
    await audioService.playBeep(300, 200);
    document.querySelector(`#${id}-game .game-item[data-word="${data.gameSelected.word}"][data-type="${data.gameSelected.type}"]`).dataset.selected = 'false';
  }

  data.gameSelected = null;
}

function completeVocab(id) {
  const data = window.__vocabData[id];
  data.phase = 'complete';

  document.getElementById(`${id}-phase-game`).dataset.active = 'false';
  document.getElementById(`${id}-phase-complete`).dataset.active = 'true';
  document.getElementById(id).dataset.phase = 'complete';

  eventBus.emit('vocab:phase:change', { id, phase: 'complete' });

  audioService.speakTTS('Ho√†n th√†nh t·ª´ v·ª±ng r·ªìi! Gi·ªèi l·∫Øm!', 'vi-VN');
}

async function finishVocab(id) {
  // Show confirmation dialog
  const confirmed = await confirmDialog.show(
    'Ti·∫øp t·ª•c b√†i h·ªçc?',
    'B·∫°n c√≥ ch·∫Øc mu·ªën qua b√†i ti·∫øp theo kh√¥ng?'
  );

  if (!confirmed) {
    return; // User cancelled
  }

  // Clean up any running vocab timers and abort signals
  cleanupVocabTimers(id);

  document.getElementById(id).dataset.status = 'complete';

  eventBus.emit('vocab:complete', { id });

  await audioService.speakTTS('C√°c em ƒë√£ ghi t·ª´ v·ª±ng r·ªìi nha. Nh·ªõ h·ªçc b√†i hen. Gi·ªù m√¨nh qua b√†i ti·∫øp theo.', 'vi-VN');

  state.setState('idle');

  setTimeout(() => playNextTS(), 500);
}

async function skipVocab(id) {
  // Clean up any running vocab processes
  cleanupVocabTimers(id);

  // Mark vocab as complete and advance
  document.getElementById(id).dataset.status = 'complete';

  eventBus.emit('vocab:skip', { id });

  state.setState('idle');

  // Continue to next section
  setTimeout(() => playNextTS(), 200);
}

// Clean up all vocab-related timers and abort any running loops
function cleanupVocabTimers(id) {
  const data = window.__vocabData[id];
  if (!data) return;

  // Stop writing timer if running
  if (data.writingTimerId) {
    timerService.stop(data.writingTimerId);
  }

  // Abort any running flashcard loop
  vocabAbortController.abort(id);

  // Stop any TTS that might be playing
  audioService.stop();

  // Hide any active timer UI
  const timerEl = document.getElementById(`${data.writingTimerId}`);
  if (timerEl) {
    timerEl.dataset.active = 'false';
  }
}

// ============ LOAD CONTENT ============
async function load() {
  if (!CONFIG.contentUrl) {
    document.getElementById('content').innerHTML = '<div class="card">No content URL provided. Use ?c=URL</div>';
    updateMainNavButton(false, 'Kh√¥ng c√≥ n·ªôi dung');
    return;
  }

  try {
    const res = await fetch(CONFIG.contentUrl);
    const md = await res.text();
    const lesson = parseLesson(md);

    state.title = lesson.title;
    state.chunks = lesson.chunks;

    document.getElementById('title').textContent = lesson.title;
    renderChunks(lesson.chunks);

    eventBus.emit('lesson:load', { title: lesson.title, chunks: lesson.chunks.length });

    // Show first chunk but don't auto-play - wait for user to click "B·∫Øt ƒë·∫ßu b√†i h·ªçc"
    document.querySelectorAll('.chunk').forEach((el, i) => {
      el.dataset.status = i === 0 ? 'active' : 'pending';
    });

    // Enable the "B·∫Øt ƒë·∫ßu b√†i h·ªçc" button
    updateMainNavButton(true, 'B·∫Øt ƒë·∫ßu b√†i h·ªçc');

  } catch (e) {
    document.getElementById('content').innerHTML = `<div class="card" style="color:#ef4444">Error: ${e.message}</div>`;
    updateMainNavButton(false, 'L·ªói t·∫£i n·ªôi dung');
  }
}

// ============ EXPOSE FOR TESTING ============
window.__voiceLecture = {
  // State access
  getState: () => state.getData(),
  getProgress: () => ({ current: state.currentChunk + 1, total: state.chunks.length, percentage: ((state.currentChunk + 1) / state.chunks.length) * 100 }),
  getChunks: () => state.chunks.map((c, i) => ({ index: i, id: c.id, title: c.title })),
  getEventHistory: () => eventBus.history,

  // Controls
  activateChunk,
  advanceToNextChunk,
  handleMainNavClick,
  skipTimer: (id) => timerService.skip(id),
  setTimerScale: (scale) => timerService.setTimeScale(scale),
  skipSpeaking,

  // Vocabulary
  startVocabFlashcard,
  skipVocabWriting,
  handleQuizAnswer,
  handleGameSelect,
  finishVocab,
  skipVocab,

  // Exercise (uses iframe modal with tieu-hoc game engine)
  startExercise,
  closeExerciseModal,
  getExerciseState: () => exerciseState,

  // NPC
  npcContinue: () => {
    if (state.getState() === 'npc_waiting') {
      hideNPC();
      playNextTS();
    }
  },

  // Confirmation Dialog
  confirmDialogConfirm: () => confirmDialog.confirm(),
  confirmDialogCancel: () => confirmDialog.cancel(),

  // Event helpers
  waitForEvent: (eventName, timeout = 5000) => {
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => reject(new Error(`Timeout: ${eventName}`)), timeout);
      eventBus.once(eventName, (data) => { clearTimeout(timer); resolve(data); });
    });
  },

  // Event bus direct access
  on: (event, cb) => eventBus.on(event, cb),
  emit: (event, data) => eventBus.emit(event, data),

  // Keyboard navigation
  handleSkipKey,
};

// ============ TELEGRAM INTEGRATION ============
// State for attendance
const telegramState = { name: '', photo: null };

// Initialize camera for attendance gate
async function initCamera() {
  const video = document.getElementById('cam-video');
  const capBtn = document.getElementById('capture-btn');
  const skipBtn = document.getElementById('skip-btn');

  skipBtn.onclick = () => {
    telegramState.name = document.getElementById('student-name').value || 'H·ªçc sinh';
    document.getElementById('gate').classList.add('hidden');
    load();
  };

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: { ideal: 480 } }, audio: false });
    video.srcObject = stream;
    capBtn.disabled = false;
    capBtn.onclick = () => {
      telegramState.name = document.getElementById('student-name').value || 'H·ªçc sinh';
      const canvas = document.getElementById('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext('2d').drawImage(video, 0, 0);
      telegramState.photo = canvas.toDataURL('image/jpeg', 0.8);
      video.style.display = 'none';
      const img = document.createElement('img');
      img.src = telegramState.photo;
      video.parentNode.insertBefore(img, video);
      capBtn.textContent = 'V√†o h·ªçc';
      capBtn.onclick = async () => {
        stream.getTracks().forEach(t => t.stop());
        await sendPhoto(telegramState.photo, `ƒêi·ªÉm danh\n${telegramState.name}\n${new Date().toLocaleString('vi-VN')}`);
        document.getElementById('gate').classList.add('hidden');
        load();
      };
    };
  } catch (e) {
    capBtn.style.display = 'none';
  }
}

// Send photo to Telegram
async function sendPhoto(data, caption) {
  if (!CONFIG.tgToken || !CONFIG.tgChat) return;
  document.getElementById('sending').classList.add('active');
  try {
    const blob = await (await fetch(data)).blob();
    const fd = new FormData();
    fd.append('chat_id', CONFIG.tgChat);
    fd.append('photo', blob, 'photo.jpg');
    fd.append('caption', caption);
    await fetch(`https://api.telegram.org/bot${CONFIG.tgToken}/sendPhoto`, { method: 'POST', body: fd });
  } catch (e) { /* silent fail */ }
  document.getElementById('sending').classList.remove('active');
}

// Send audio to Telegram
async function sendAudio(blob, caption) {
  if (!CONFIG.tgToken || !CONFIG.tgChat) return;
  document.getElementById('sending').classList.add('active');
  try {
    const fd = new FormData();
    fd.append('chat_id', CONFIG.tgChat);
    fd.append('voice', blob, 'voice.ogg');
    fd.append('caption', caption);
    await fetch(`https://api.telegram.org/bot${CONFIG.tgToken}/sendVoice`, { method: 'POST', body: fd });
  } catch (e) { /* silent fail */ }
  document.getElementById('sending').classList.remove('active');
}

// Capture homework photo
async function captureHW(id) {
  const div = document.getElementById(`${id}-photo`);
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
    const modal = document.createElement('div');
    modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.95);z-index:1000;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:16px';
    modal.innerHTML = `<video autoplay playsinline style="max-width:100%;max-height:70vh;border-radius:10px"></video><div style="margin-top:12px"><button class="gate-btn" id="hw-cap">Ch·ª•p</button><button class="gate-btn secondary" onclick="this.closest('div').parentElement.remove()">H·ªßy</button></div>`;
    document.body.appendChild(modal);
    modal.querySelector('video').srcObject = stream;
    modal.querySelector('#hw-cap').onclick = async () => {
      const v = modal.querySelector('video');
      const c = document.createElement('canvas');
      c.width = v.videoWidth;
      c.height = v.videoHeight;
      c.getContext('2d').drawImage(v, 0, 0);
      const url = c.toDataURL('image/jpeg', 0.85);
      stream.getTracks().forEach(t => t.stop());
      modal.remove();
      div.innerHTML = `<img src="${url}" style="max-width:100%;border-radius:8px;margin-top:8px">`;
      await sendPhoto(url, `B√†i l√†m\n${telegramState.name}\n${new Date().toLocaleString('vi-VN')}`);
    };
  } catch (e) {
    alert('Kh√¥ng th·ªÉ m·ªü camera: ' + e.message);
  }
}

// Expose functions to window
window.captureHW = captureHW;
window.sendPhoto = sendPhoto;
window.sendAudio = sendAudio;

// ============ VOICE RECORDING ============
let recorder = null;
let recordChunks = [];

// Extract lesson info from content URL for caption
function getLessonInfo() {
  const url = CONFIG.contentUrl || '';
  // Match pattern: g{grade}/unit-{unit}/{section}.md
  const match = url.match(/g(\d+)\/unit-(\d+)\/([^\/]+)\.md/);
  if (match) {
    return `L·ªõp ${match[1]} - Unit ${parseInt(match[2])} - ${match[3]}`;
  }
  // Check for grammar topic
  const grammarMatch = url.match(/grammar\/([^\/]+)\.md/);
  if (grammarMatch) {
    return `Ng·ªØ ph√°p - ${grammarMatch[1]}`;
  }
  return 'B√†i h·ªçc';
}

// Toggle recording on/off
async function toggleRec(id) {
  const btn = document.getElementById(`${id}-rec`);
  const player = document.getElementById(`${id}-player`);
  if (!btn) return;

  // Stop if already recording
  if (recorder && recorder.state === 'recording') {
    recorder.stop();
    btn.classList.remove('recording');
    btn.querySelector('span').textContent = 'Ghi √¢m';
    return;
  }

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    recorder = new MediaRecorder(stream);
    recordChunks = [];

    recorder.ondataavailable = e => recordChunks.push(e.data);

    recorder.onstop = async () => {
      const blob = new Blob(recordChunks, { type: 'audio/webm' });
      player.innerHTML = `<div class="audio-box"><audio controls src="${URL.createObjectURL(blob)}"></audio></div>`;
      // Build caption with lesson info and student name
      const lessonInfo = getLessonInfo();
      const caption = `Ghi √¢m\n${lessonInfo}\n${telegramState.name}\n${new Date().toLocaleString('vi-VN')}`;
      await sendAudio(blob, caption);
      stream.getTracks().forEach(t => t.stop());
    };

    recorder.start();
    btn.classList.add('recording');
    btn.querySelector('span').textContent = 'D·ª´ng';
  } catch (e) {
    alert('Kh√¥ng th·ªÉ ghi √¢m: ' + e.message);
  }
}

window.toggleRec = toggleRec;

// ============ KEYBOARD NAVIGATION ============
function setupKeyboardNav() {
  document.addEventListener('keydown', (e) => {
    if (e.key !== 'ArrowRight') return;
    e.preventDefault();
    handleSkipKey();
  });
}

function handleSkipKey() {
  // Try to click visible skip/continue buttons in priority order
  const selectors = [
    '#skip-speaking-btn',                      // Skip TTS
    '[data-testid="speech-continue-btn"]',     // NPC continue
    '.timer-skip',                             // Skip timer
    '.vocab-skip-btn',                         // Skip vocab
    '#main-nav-btn[data-ready="true"]',        // Main nav (next chunk / start)
  ];

  for (const sel of selectors) {
    const btn = document.querySelector(sel);
    if (btn && btn.offsetParent !== null) {
      btn.click();
      return;
    }
  }
}

// Start
document.addEventListener('DOMContentLoaded', () => {
  setupKeyboardNav();
  // Skip gate if: skip flag, no Telegram config, or test mode
  if (CONFIG.skip || !CONFIG.tgToken || !CONFIG.tgChat || CONFIG.testMode) {
    document.getElementById('gate').classList.add('hidden');
    load();
  } else {
    initCamera();
  }
});
</script>
</body>
</html>
